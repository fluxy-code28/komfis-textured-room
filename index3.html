<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Textured Room – Individual Walls (sRGB + fixed floor)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background:#111; }
    canvas { display: block; }
    .hint{
      position: absolute; top:10px; left:50%; transform:translateX(-50%);
      color:#ddd; font:14px system-ui,sans-serif; background:rgba(0,0,0,.35);
      padding:6px 10px; border-radius:8px; user-select:none;
    }
  </style>
</head>
<body>
  <div class="hint">Drag = rotate · Scroll = zoom · Right-drag = pan · R = reset camera</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // ===== 1) Scene, Camera, Renderer =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.05, 200);
    const defaultPos = new THREE.Vector3(0, 1.5, 3);
    camera.position.copy(defaultPos);
    camera.lookAt(0, 1, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 1, 0);
    controls.minDistance = 0.3;
    controls.maxDistance = 12;

    // ===== 2) Lights =====
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    const point   = new THREE.PointLight(0xffffff, 1.0, 100);
    point.position.set(0, 2.4, 0);
    scene.add(ambient, point);

    // ===== 3) Texture loader + fallback =====
    const loader = new THREE.TextureLoader();

    function makeFallback(label) {
      const c = document.createElement('canvas'); c.width = c.height = 256;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0,0,256,256);
      ctx.fillStyle = '#999'; ctx.font = '16px system-ui'; ctx.fillText(label, 20, 130);
      const t = new THREE.CanvasTexture(c);
      t.encoding = THREE.sRGBEncoding;
      t.generateMipmaps = true;
      t.minFilter = THREE.LinearMipmapLinearFilter;
      t.magFilter = THREE.LinearFilter;
      return t;
    }

    function safeLoad(path, label) {
      let tex = loader.load(
        path,
        () => { tex.needsUpdate = true; },
        undefined,
        () => { tex = makeFallback(label); }
      );
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.minFilter = THREE.LinearMipmapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.encoding = THREE.sRGBEncoding;
      return tex;
    }

    const floorTex   = safeLoad('floor.jpg',   'floor.jpg?');
    const wallTex    = safeLoad('wall.jpg',    'wall.jpg?');
    const ceilingTex = safeLoad('ceiling.jpg', 'ceiling.jpg?');

    floorTex.repeat.set(2, 2);
    wallTex.repeat.set(1.5, 1);
    ceilingTex.repeat.set(1, 1);

    floorTex.center.set(0.5, 0.5);
    floorTex.rotation = Math.PI;

    // ===== 4) Materials =====
    const matFloor   = new THREE.MeshStandardMaterial({ map: floorTex,   side: THREE.FrontSide });
    const matWall    = new THREE.MeshStandardMaterial({ map: wallTex,    side: THREE.FrontSide });
    const matCeiling = new THREE.MeshStandardMaterial({ map: ceilingTex, side: THREE.FrontSide });

    // ===== 5) Geometry satu per satu =====
    const W = 4, H = 3, D = 6;

    // LANTAI
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matFloor);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set(0, 0, 0);
    scene.add(floor);

    // ATAP
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matCeiling);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.set(0, H, 0);
    scene.add(ceiling);

    // DINDING BELAKANG (z = -D/2) - menghadap +Z
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
    backWall.position.set(0, H/2, -D/2);
    scene.add(backWall);

    // DINDING DEPAN (z = +D/2) - menghadap -Z
    const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
    frontWall.rotation.y = Math.PI;
    frontWall.position.set(0, H/2, D/2);
    scene.add(frontWall);

    // DINDING KIRI (x = -W/2) - supaya menghadap ke dalam (+X)
    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
    leftWall.rotation.y = Math.PI / 2;   // perhatikan: dulu -π/2 → sekarang +π/2
    leftWall.position.set(-W/2, H/2, 0);
    scene.add(leftWall);

    // DINDING KANAN (x = +W/2) - supaya menghadap ke dalam (-X)
    const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
    rightWall.rotation.y = -Math.PI / 2;  // dulu +π/2 → sekarang -π/2
    rightWall.position.set(W/2, H/2, 0);
    scene.add(rightWall);

    // ===== 6) Loop & events =====
    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        camera.position.copy(defaultPos);
        controls.target.set(0, 1, 0);
        camera.lookAt(0, 1, 0);
        controls.update();
      }
    });
  </script>
</body>
</html>
